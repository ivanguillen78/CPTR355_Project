<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Final Project - Ferris Wheel</title>

    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>

    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <script>
        var canvas = null;
        var engine = null;

        /******* Add the create scene function ******/
        var createScene = function () {
            var scene = new BABYLON.Scene(engine);

            var camera = new BABYLON.ArcRotateCamera("Camera", 0, 0, 0, BABYLON.Vector3.Zero(), scene);
            camera.setPosition(new BABYLON.Vector3(-10, 280, 400));
            camera.attachControl(canvas, true);

            var light = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.1;

            var music = new BABYLON.Sound("synth", "song.wav", scene, null, { loop: true, autoplay: true });

            var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 1000, height: 1000 }, scene);
            var groundMat = new BABYLON.StandardMaterial("groundMat", scene);
            groundMat.diffuseColor = new BABYLON.Color3.Black();
            ground.material = groundMat;

            function tube_circle() {
                circle_points = [];
                for (let i = 0; i <= 360; i++) {
                    let angle = i * (2 * Math.PI / 360);
                    circle_points.push(new BABYLON.Vector3((1 + Math.cos(angle)) * 50, (Math.sin(angle)) * 50, 0));
                }
                var circle = circle = BABYLON.MeshBuilder.CreateTube("lines", { path: circle_points, radius: 0.5 }, scene);
                circle_material = new BABYLON.StandardMaterial("circle_mat", scene);
                circle_material.emissiveColor = new BABYLON.Color3(0.138 * 3, 0.255 * 3, 0.251 * 3);
                circle.material = circle_material;
                var gl = new BABYLON.GlowLayer("glow", scene);
                gl.intensity = 0.35;
                return circle;
            }

            function support1() {
                support_points = [
                    new BABYLON.Vector3(0, 50, 0),
                    new BABYLON.Vector3(0, 0, 0),
                    new BABYLON.Vector3(0, 0, -10),
                    new BABYLON.Vector3(0, 50, -10)
                ];

                var support = BABYLON.MeshBuilder.CreateTube("support", { path: support_points, radius: 0.3 }, scene);
                // support_material = new BABYLON.StandardMaterial("support_mat", scene);
                // support_material.emissiveColor = new BABYLON.Color3(1, 1, 1);
                // support.material = support_material;
                return support;
            }

            function support2() {
                support_points = [
                    new BABYLON.Vector3(0, 0, 0),
                    new BABYLON.Vector3(0, 12.5, -10),
                    new BABYLON.Vector3(0, 12.5, 0),
                    new BABYLON.Vector3(0, 25, -10),
                    new BABYLON.Vector3(0, 25, 0),
                    new BABYLON.Vector3(0, 37.5, -10),
                    new BABYLON.Vector3(0, 37.5, 0),
                    // new BABYLON.Vector3(0, 50, -10),
                    // new BABYLON.Vector3(0, 50, 0),
                ];
                var support2 = BABYLON.MeshBuilder.CreateTube("support", { path: support_points, radius: 0.3 }, scene);
                return support2;
            }

            function stand() {
                var stand = BABYLON.MeshBuilder.CreateBox("stand", { height: 120, width: 7, depth: 7 }, scene)
                return stand;
            }

            function stands() {
                f_stand1 = stand();
                f_stand2 = stand();
                b_stand1 = stand();
                b_stand2 = stand();

                f_stand1.position = new BABYLON.Vector3(30, 46, 20);
                f_stand1.addRotation(0, 0, Math.PI / 6);
                f_stand2.position = new BABYLON.Vector3(-30, 46, 20);
                f_stand2.addRotation(0, 0, -Math.PI / 6);

                b_stand1.position = new BABYLON.Vector3(30, 46, -15);
                b_stand1.addRotation(0, 0, Math.PI / 6);
                b_stand2.position = new BABYLON.Vector3(-30, 46, -15);
                b_stand2.addRotation(0, 0, -Math.PI / 6);

                stand_center = BABYLON.MeshBuilder.CreateCylinder("stand_center", { height: 42, diameter: 9 }, scene);
                stand_center.position = new BABYLON.Vector3(0, 100, 2.5);
                stand_center.addRotation(Math.PI / 2, 0, 0);
            }

            function lights(mesh) {
                var particleSystem = new BABYLON.ParticleSystem("particles", 2000, scene);
                particleSystem.particleTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/fire.jpg", scene);
                particleSystem.emitter = new BABYLON.Vector3(0, 100, 11);
                particleSystem.emitter = mesh;
                particleSystem.color1 = new BABYLON.Color3(0, 1, 1);
                particleSystem.color2 = new BABYLON.Color3(0, 1, 1);
                particleSystem.minSize = 4.2;
                particleSystem.maxSize = 4.2;
                particleSystem.minLifeTime = 0.45;
                particleSystem.maxLifeTime = 0.45;
                //particleSystem.emitRate = 2.9; //4
                particleSystem.direction1 = new BABYLON.Vector3(28, -4, 0);
                particleSystem.direction2 = new BABYLON.Vector3(28, -4, 0);
                particleSystem.minEmitPower = 4;
                particleSystem.maxEmitPower = 4;
                particleSystem.updateSpeed = 0.009;
                particleSystem.minEmitBox.x = 0;
                particleSystem.maxEmitBox.x = 0;
                particleSystem.minEmitBox.y = 0;
                particleSystem.maxEmitBox.y = 0;
                particleSystem.maxEmitBox.z = 0;
                particleSystem.minEmitBox.z = 0;
                return particleSystem;
            }

            function disappearing_beam(mesh_list, offset, color) {
                for (let mesh in mesh_list) {
                    light = lights(mesh_list[mesh]);
                    light.color1 = color;
                    light.color2 = color;
                    light.start(offset);
                    light.targetStopDuration = 0.3;
                    light.addEmitRateGradient(0, 500);
                    light.addEmitRateGradient(1, 1000);
                }
                // light.addColorGradient(0, new BABYLON.Color3(0,1,1));
                // light.addColorGradient(1, new BABYLON.Color3.White());
            }

            function simple_emit(mesh_list, offset, color, emitRate) {
                for (let mesh in mesh_list) {
                    light = lights(mesh_list[mesh]);
                    light.color1 = color;
                    light.color2 = color;
                    light.emitRate = emitRate;
                    light.start(offset);
                }
            }

            function lightSequence(mesh_list) {
                var all = mesh_list;
                var every_other1 = [
                    mesh_list[0],
                    mesh_list[2],
                    mesh_list[4],
                    mesh_list[6],
                    mesh_list[8],
                    mesh_list[10]
                ]
                var every_other2 = [
                    mesh_list[1],
                    mesh_list[3],
                    mesh_list[5],
                    mesh_list[7],
                    mesh_list[9],
                    mesh_list[11]
                ]
                var quarter1 = [
                    mesh_list[0],
                    mesh_list[1],
                    mesh_list[2]
                ]
                var quarter2 = [
                    mesh_list[3],
                    mesh_list[4],
                    mesh_list[5]
                ]
                var quarter3 = [
                    mesh_list[6],
                    mesh_list[7],
                    mesh_list[8]
                ]
                var quarter4 = [
                    mesh_list[9],
                    mesh_list[10],
                    mesh_list[11]
                ]
                var cross1 = [
                    mesh_list[0],
                    mesh_list[3],
                    mesh_list[6],
                    mesh_list[9],
                ]
                var cross2 = [
                    mesh_list[1],
                    mesh_list[4],
                    mesh_list[7],
                    mesh_list[10],
                ]
                var cross3 = [
                    mesh_list[2],
                    mesh_list[5],
                    mesh_list[8],
                    mesh_list[11],
                ]
                var opposite1 = [
                    mesh_list[0],
                    mesh_list[6]
                ]
                var opposite1 = [
                    mesh_list[1],
                    mesh_list[7]
                ]
                var opposite1 = [
                    mesh_list[2],
                    mesh_list[8]
                ]
                var opposite1 = [
                    mesh_list[3],
                    mesh_list[9]
                ]
                var opposite1 = [
                    mesh_list[4],
                    mesh_list[10]
                ]
                var opposite1 = [
                    mesh_list[5],
                    mesh_list[11]
                ]
    
                // TODO: Create light show sequence
                // TODO: Create more patterns to facilitate sequence creation.

                //one = pattern1(every_other1, 0);
                // two = pattern1(quarter3, 1000);
                // three = pattern1(quarter2, 2000);
                // four = pattern1(quarter4, 3000)
                threeA1 = disappearing_beam(every_other1, 0, new BABYLON.Color3.Blue());
                threeA2 = disappearing_beam(every_other2, 100, new BABYLON.Color3(0,1,1));
                four = simple_emit(all, 300, new BABYLON.Color3.Magenta(), 5);

                // threeA2 = pattern2(every_other1, 100, new BABYLON.Color3(0,1,1), 7);
                // threeB1 = pattern2(every_other2, 200, new BABYLON.Color3(0,0,1), 7);
                // threeB2 = pattern2(every_other2, 250, new BABYLON.Color3(0,0,1), 7);
                //threeB = pattern2(every_other2, 200, new BABYLON.Color3.Blue(), 7);
                // threeB1 = pattern2(mesh, 3200, new BABYLON.Color3.Blue(), 7);
                // threeC = pattern2(mesh, 3400, new BABYLON.Color3(0.76, 0.58, 1, 10));
                // threeC1 = pattern2(mesh, 3400, new BABYLON.Color3(0.76, 0.58, 1, 10));
                // one = pattern1(mesh, 10000);
                // two = pattern1(mesh, 11000);
            }

            function ferris_wheel() {
                circle1 = tube_circle();
                circle1.position = new BABYLON.Vector3(-75, 100, -5)
                circle1.scaling = new BABYLON.Vector3(1.5, 1.5, 1.5);

                circle2 = tube_circle();
                circle2.position = new BABYLON.Vector3(-75, 100, 10);
                circle2.scaling = new BABYLON.Vector3(1.5, 1.5, 1.5);

                var circle_lights = new BABYLON.Animation("circle_lights", "material.emissiveColor", 30, BABYLON.Animation.ANIMATIONTYPE_COLOR3,
                    BABYLON.Animation.ANIMATIONLOOPMODE_LOOP);
                var keys = [];
                keys.push({
                    frame: 0,
                    value: new BABYLON.Color3.Blue()
                });
                keys.push({
                    frame: 100,
                    value: new BABYLON.Color3(0, 1, 1)
                });
                keys.push({
                    frame: 200,
                    value: new BABYLON.Color3.Blue()
                });
                keys.push({
                    frame: 300,
                    value: new BABYLON.Color3(0.76, 0.58, 1)
                });
                keys.push({
                    frame: 400,
                    value: new BABYLON.Color3.Blue()
                });
                circle_lights.setKeys(keys);
                circle1.animations.push(circle_lights);
                circle2.animations.push(circle_lights);
                scene.beginAnimation(circle1, 0, 400, true, 5);
                scene.beginAnimation(circle2, 0, 400, true, 5);

                var center = BABYLON.MeshBuilder.CreateCylinder("center", { height: 0, diameter: 0 }, scene);
                center.position = new BABYLON.Vector3(0, 100, 2.5);
                center.addRotation(0, 0, 0);

                center.addChild(circle1);
                center.addChild(circle2);

                let counter = 0;
                let angle = 0;
                var support_beam_list = []

                while (counter < 12) {
                    support_beam1 = support1();
                    support_beam1.material = groundMat;
                    support_beam1.position = new BABYLON.Vector3(0, 100, 10);
                    support_beam1.addRotation(0, 0, angle);
                    support_beam1.scaling = new BABYLON.Vector3(1.5, 1.5, 1.5);

                    support_beam2 = support2();
                    support_beam2.material = groundMat;
                    support_beam2.position = new BABYLON.Vector3(0, 100, 10);
                    support_beam2.addRotation(0, 0, angle);
                    support_beam2.scaling = new BABYLON.Vector3(1.5, 1.5, 1.5);

                    support_beam_list.push(support_beam2);

                    lightSequence(support_beam_list);

                    center.addChild(support_beam1);
                    center.addChild(support_beam2);
                    counter = counter + 1;
                    angle = angle + Math.PI / 6;
                }

                const animWheel = new BABYLON.Animation("wheelAnimation", "rotation.z", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_RELATIVE);
                const wheelKeys = [{ frame: 0, value: 0 }, { frame: 30, value: -Math.PI / 16.5 }];
                animWheel.setKeys(wheelKeys);
                center.animations = [animWheel];
                scene.beginAnimation(center, 0, 30, true);
            }

            stands();
            ferris_wheel();

            return scene;
        }
        /******* End of the create scene function ******/

        function init() {
            canvas = document.getElementById("renderCanvas");
            engine = new BABYLON.Engine(
                canvas,
                true,
                { preserveDrawingBuffer: true, stencil: true, disableWebGL2Support: false }
            );

            let scene = createScene();

            // Register a render loop to repeatedly render the scene
            engine.runRenderLoop(function () {
                scene.render();
            });

            // Watch for browser/canvas resize events
            window.addEventListener("resize", function () {
                engine.resize();
            });

        }

    </script>

</head>

<body onload="init()">
    <canvas id="renderCanvas"></canvas>
</body>

</html>